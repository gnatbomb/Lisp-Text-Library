



; Question 1
; issorted(L)
;	if null (cdr L) then T					#if the next element is nil, then list is sorted
;	else if (> (car L) (car (cdr L))) then NIL		#if the current front element is > next element, list is not sorted. return nil.
;	else issorted(cdr L)					#recursive call on list excluding first element
;	
;

(defun issorted (L)
	(if (null (cdr L))
		T
		(if (>= (car L) (cadr L))
			NIL
			(issorted (cdr L))
		)
	)
)


;Question 2
; numbers(N)
;	if (>= 0 N) then NIL				#N is 0 or less
;	else (append (numbers(N - 1)) (cons N NIL))	#Adds N to the end of the return list. Decrements N and makes recursive call.

(defun numbers(N)
	(if (>= 0 N)
		NIL
		(append (numbers (- N 1)) (cons N NIL))
	)
)


;Question 3							#reverse the list using helper function defined as myreverse, then compare using equals function
;
;myreverse(L)							#reverses the order of a list
;	if (null L) then L					#if at end of list, stop recursing
;	else (append (myreverse (cdr L)) (cons (car L) NIL))	#add current first element to end of list, and recurse on remaining elements
;
;palindrome(L)
;	equal (L myreverse(L))					#sees if the list is identical to itself when reversed.	

(defun myreverse(L)
	(if (null L)
		L
		(append (myreverse (cdr L)) (cons (car L) NIL))
	)
)

(defun palindrome(L)
	(equal L (myreverse L))
)


;Question 4
;
;replace1(A B L)			#replaces all instances of A with B in given List L, ignoring sublists
;	if (null L) then L		#ceases recursive call at end of list
;	else 
;		(if (eq (car L) A) then (append B (replace1 A B (cdr L)) NIL)	#First element in L is A. replace with B, and recurse on (cdr L)
;		else (append (cons (car L) NIL) (replace1 A B (cdr L)) NIL)	#First element in L isnt A. add it to list, and recurse on (cdr L)

(defun replace1(A B L)
	(if (null L)
		L
		(if (eq (car L) A)
			(append (cons B NIL) (replace1 A B (cdr L)))
			(append (cons (car L) NIL) (replace1 A B (cdr L)))
		)
	)
)

;
;replace2(A B L)			#replaces all instances of A with B in given List L, including sublists
;	if (null L) then L		#ceases recursive call at end of list
;	else 
;		(if (atom (car L)		#if the first element of L is an atom, proceed as in replace1. Else, recurse on that list
;			(if (eq (car L) A) then (append B (replace2 A B (cdr L)) NIL)	#First element in L is A. replace with B, and recurse on (cdr L)
;			else (append (cons (car L) NIL) (replace2 A B (cdr L)) NIL)	#First element in L isnt A. add it to list, and recurse on (cdr L)
;		else (append (cons (replace2(A B (car L) NIL) (replace2 A B (cdr L)) NIL))	#recurses on first element of list, then proceeds accordingly

(defun replace2(A B L)
	(if (null L)
		L
		(if (atom (car L))
			(if (eq (car L) A)
				(append (cons B NIL) (replace2 A B (cdr L)))
				(append (cons (car L) NIL) (replace2 A B (cdr L)))
			)
			(append (cons (replace2 A B (car L)) NIL) (replace2 A B (cdr L)))
		)
	)
)


;
;common(A B)				#counts how many atoms in list A are also in list B. Atoms in a list never repeat.
;	if (null A) then 0		#A has no more elements, so no elements in common with B
;	else if (null (member (car A) B)) then (common (cdr A) B))	#returns true if car(A) is not in B, and recurses on cdr(A)
;	else 1 + (common (cdr A) B))					#if car(A) was in B, then adds 1 and recurses on cdr(A)
;

(defun common(A B)
	(if (null A)
		0
		(if (null (member (car A) B))
			(common (cdr A) B)
			(+ 1 (common (cdr A) B))
		)
	)
)